h1. Mongoモジュール

p. mongoモジュールは、"MongoDB":http://www.mongodb.org サポートをPlay! frameworkに追加します。


h2. <a>アプリケーションでMongoモジュールを有効にする</a>

p. **/conf/application.conf**ファイルに以下の行を追加すれば、Mongoモジュールが有効になります。

bc.. # The mongo module
module.mongo=${play.path}/modules/mongo

# mongodb connection details
mongo.host=localhost
mongo.port=27017
mongo.database=play

mongo.username=test
mongo.password=test123

h2. <a>モデルの定義</a>

p. Mongoデータベースに保存するモデルは、Play! frameworkでSQLデータベースに保存するためのモデルとよく似た方法で生成します。以下のように、アノテーションを付けて、ベースクラスから継承します。

bc.. @MongoEntity("collectionName")
public class Car extends MongoModel {

	public String name;
	public String colour;
	public int topSpeed;
	
}

p. アノテーションに値としてcollectionNameが渡されなかった場合、コレクション名はクラス名と同じになります。

h2. <a>モデルの利用</a>

p. モデルを定義したら、それらはPlay! frameworkの標準的なSQLベースのモデルと同じように使うことができます。以下の例を見れば、コントローラでMongoベースのモデルの使い方が分かるでしょう。

h3. 保存

p. 保存は簡単です。

bc.. Car myCar = new Car("Toyota", "white", 150);
myCar.save();

h3. 検索

p. モデルの検索方法はいくつかあります。

bc.. //全ての Carの取得
List<Car> allCars = Car.find().fetch();

//任意の5つのCarの取得
List<Car> fiveCars = Car.find().fetch(5);

//オフセット3から2台のCarの取得
List<Car> offsetCars = Car.find().from(3).fetch(2);

//20台のCarからなるページの3ページ目を取得
List<Car> pageOfCars = Car.find().fetch(3,20);

//1つのCarを取得
Car c = Car.find().first();

h3. クエリ文字列

p. findメソッドを使用する際には、クエリ文字列を以下のように渡すことができます。

bc.. List<Car> toyotas = Car.find("byName", "Toyota").fetch();

List<Car> whiteToyotas = Car.find("byNameAndColour", "Toyota", "white").fetch();

p. 現時点では、Mongoモジュールがクエリ演算子としてサポートしているのは'And'のみです。

h3. 順序の指定

p. 結果の順序を指定するのは非常に単純で、その場合のクエリの使い方はfindととてもよく似ています。

bc.. List<Car> ascendingNameCars = Car.find().order("byName").fetch();

// 降順を指定するには、フィールドの前に'-'を加えます。
List<Car> descendingNameCars = Car.find().order("by-Name").fetch();

h3. モデルの数を数える

p. モデルの数を数えるのも、やはり簡単です。

bc.. long count = Car.count()

// あるいは、クエリ文字列を渡すこともできます。
long toyotaCount = Car.count("byName", "Toyota");

h3. 削除

p. 削除はモデルのレベルで行うこともできますし、コレクション全体を削除してしまうこともできます。

bc.. Car c = Car.find().first();
c.delete();

// あるいはクエリ文字列を使って削除したり
Car.delete("byName","Toyota");

// あるいは単純に全部削除することもできます。
Car.deleteAll();

h3. インナーモデル

p. Mongoモジュールは、今のところモデル間のリレーションシップはサポートしていません。複雑なリレーションシップをモデル化する必要がある場合は、このMongoモジュールは適切な選択肢ではないかも知れません。

p. とはいえ、Mongoモジュールは、インナーモデルやMongoModelクラス中のPOJOをサポートしています。 加えて、プリミティブ型やPOJOのどちらの配列もサポートしています。残念ながら、コレクションでサポートされているのは今のところプリミティブ型のみです。これは、実行時にジェネリック型が消失してしまうためです。 

bc.. //バージョン1.1では、インナーPOJOのために特別なアノテーションは必要なくなった。
public class Driver {
	public String name;
}

// そして、このオブジェクトがモデルクラスのメンバーであることを宣言する
@MongoEntity("cars")
public class Car extends MongoModel {

	public String name;
	public String colour;
	public int topSpeed;

	// mongoオブジェクト
	public Driver driver;
	
}

p. これで、MongoModelをmongoのデータベースに保存すれば、MongoObjectはインナーJSONオブジェクトとして保存される。こうすれば、viewテンプレートで、親のモデルを通じて子のオブジェクトのプロパティにアクセスできるようになる。

bc.. <p> Driver Name: ${car.driver.name} </p>

p. また、インナーモデルのプロパティは、クエリ文字列の一部としても使うことができる。

bc.. Car andrewCar = Car.find(byDriver.name,"Andrew").first();

h2. <a>Mongoモジュールの独自機能</a>

h3. Mongo情報

p. モデルは、自動的にMongo ObjectIdを割り当てられ、指定されたコレクションに保存される。ObjectIdとコレクション名は、どちらもモデルからアクセスできる。

bc.. Car myCar = new Car("Toyota", "white", 150);
myCar.save();

ObjectId id = myCar.get_id();
String colName = myCar.getCollectionName();

h3. Mongoインデックス

p. モデルに対しては、インデックスを作成できる。

bc.. // Carのnameフィールドにインデックスを付ける
Car.index("onName");

// '-'を前に付けることで、降順インデックスを生成する
Car.index("on-Name");

// 複合インデックスを生成するには、フィールド名を組み合わせる
Car.index("onNameAndColour");

// インデックスの削除
Car.dropIndex("onName);

// 全てのインデックスの削除(必須のmongo index on _idを除く)
Car.dropIndexes();

// 既存の全インデックス名を取得
String [] indexNames = Car.getIndexes();

p. mongoはスキーマレスなので、存在しないフィールドに対してインデックスを生成することができます。これは、そのフィールドを含むドキュメントが、将来インサートされるかも知れないからです。フィールド名が正しく書かれているか、しっかり確認してください。

h3. 認証とセキュリティ

p. mongoデータベースをセキュアモードで実行し、保護されたデータに対する操作を実行する場合には、ユーザーが認証を受けなければならないようにする事ができます。セキュアなmongoインスタンスを設定する情報がもっと必要な場合は、Mongoのウェブサイトの"Security and Authentication":http://www.mongodb.org/display/DOCS/Security+and+Authenticationを参照してください。

p. データベースを正しく設定できたら、以下のようにmongoモジュールの認証機能を活用できます。

bc.. # 必要なデータベースの認証設定のパラメータが、正しく設定できていることを確認する
mongo.username=test
mongo.password=test123

p. これで、コントローラで以下のような操作が行えるようになる。

bc.. //ユーザーの追加 - アクセスはリードオンリーで
MongoDB.addUser("username","password", true);

// あるいは書き込み可能なアクセス
MongoDB.addUser("username2","password2", false);

// ユーザーとして認証を受ける
boolean success = MongoDB.authenticate("username","password");

// ユーザーの削除
MongoDB.removeUser("username");

p. readOnlyの制約が適用できるのは、mongoのversions 1.3.2以降のみということに注意してください。

h2. <a>テストアプリケーション</a>

p. 子のモジュールのディストリビューションには、play-mongo-testディレクトリがあります。このplay frameworkのアプリケーションは、このドキュメンテーションでここまで取り上げたコードを実行します。このアプリケーションを実行する最も良い方法は、play frameworkのアプリケーションを新しく生成し、play-mongo-testディレクトリの中身をそこにコピーしてやることです。先に示した通り、mongoモジュールへのパスを更新するのを忘れないようにしてください。 

h2. <a>この先は?</a>

p. play-mongoの次のステップは、このモジュールを更新して、play framework 1.1で提供された新しいJPAの機能を使えるようにすることです。