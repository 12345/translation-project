h1. 国際化

国際化 (I18N) とは、アプリケーションを異なる言語に適応させ、地域の差異を吸収することを意味します。アプリケーションを国際化対応可能にするためには、以下の手順に従ってください。

h2. <a name="utf8">使用するのは UTF-8 だけ!</a>

Play はたったひとつの文字エンコーディングをサポートします: UTF-8 です。文字エンコーディングの問題は異様で扱いが難しいので、Play は、ただひとつの文字エンコーディングをサポートすることを選択しました。UTF-8 では、すべての言語のすべての文字を表示することができます。

アプリケーション全体を通して、一貫して UTF-8 を使用するよう気を付けてください:

* すべてのソースファイルを UTF-8 として編集してください
* HTTP ヘッダに適切な文字エンコーディングを定義してください
* HTML meta タグに UTF-8 を設定してください
* データベースを使用する場合は、UTF-8 を使用するようデータベースを設定し、常に UTF-8 を使用して接続してください

p(note). **注意**
 
The UTF-8 encoding issue is the reason why most of the Play configuration files, even though they are Java properties files, are not named @*.properties@. Java imposes the requirement that properties files must be encoded with the **ISO-8859-1** encoding. Play configuration files must be UTF-8 encoded. Need we say more?

h2. <a name="messages">メッセージの外部化</a>

I18N をサポートするには、アプリケーション中のすべてのメッセージを外部化しなければなりません。

Create a file named @messages@ in the application’s @conf/@ directory. This file is really just a Java properties file.

bc. hello=Hello!
back=Back

Then you can define a specific @message@ file for each language used in your application. Just add the ISO language code as a file extension. 

For example, the message file containing the corresponding French translations is @conf/messages.fr@:

bc. hello=Bonjour!
back=Retour

h2. <a name="languages">アプリケーションがサポートする言語の定義</a>

Define a list of supported languages in the "application.langs configuration":configuration#application.langs.

On the first request from a new user, Play will guess the default language to use. It does so by parsing the HTTP @Accept-language@ header. It will then save the chosen language in a @PLAY_LANG@ cookie. So the next request will use the same language.

en_US と en_GB や zh_CN と zh_TW のようなバリアントを区別するために、言語/国のペアを使うこともできます。しかし、あるユーザは Accept-language において言語のみを提示し、国を提示しないかもしれないことに注意してください。このような理由から、常に (例えば en のような) "生の" 言語を提供すべきです。

例えば、ユーザのほとんどが US からやってくるけれど、イギリス英語もサポートしたい場合、アメリカ英語には単に "en" を使い、イギリス英語に "en_GB" を使うことをお勧めします。

From your application code your can retrieve the current language for the user by accessing the @play.i18n.Lang@ object:

bc. String lang = Lang.get();

このユーザの言語情報を恒久的に変更したい場合は、change() メソッドを使用します:

bc. Lang.change("ja");

新しい値は、このユーザの言語クッキーに保存し直されます。


h2. <a name="dates">ロケールに沿った日付データフォーマット</a>

Configure "date.format":configuration#date.format to specify the default date format to use.


h2(#retrieve). <a>Retrieve localized messages</a>


h3(#argument). Message arguments

From the application code, you can retrieve messages defined in message files. From Java, use the @play.i18n.Messages@ object.

bc. public static void hello() {
    renderText(Messages.get("hello"));
}

We support message formatting through the standard @java.util.Formatter@ ‘Format string syntax’. You can also define dynamic content in your messages:

bc. hello=Hello %s!

where @%s@ represents a message argument that will be output as a @String@. Message arguments are provided by additional (varargs) arguments to @Messages.get@:

bc. public static void hello(String user) {
    renderText(Messages.get("hello", user));
}

h3(#template). Template output

From a template you can use the special @&{…}@ syntax to display localized messages:

bc. <h1>&{'hello'}</h1>

or using dynamic content in message arguments:

bc. <h1>&{'hello', params.user}</h1>


h3(#arguments). Multiple arguments

You can define multiple message arguments, such as this message which refers to two ‘decimal integer’ arguments:

bc. guess=Please pick a number between %d and %d

which you display by specifying the message arguments in the right order:

bc. <p>&{'guess', low, high}</p>


h3(#indices). Argument indices

You can also specify the message argument explicitly, to use a different order. For example, suppose a message in English has two parameters:

bc. guess.characteristic=Guess %s’s %s.

with message output like:

bc. <p>&{'guess.characteristic', person.name, 'age'}</p>

The French localisation has the two message in the opposite order, so in the French localisation we specify the argument indices:

bc. guess.characteristic=Devinez %2$s de %1$s.

where @%2$s@ outputs the **second** argument as a decimal integer.

Finally, we want to localise the characteristic name ‘age’ as well, so we would change the output to use the message key @person.age@, and change the message definitions to:

bc. guess.characteristic=Guess %s’s &{%s}.
person.age = age

and

bc. guess.characteristic=Devinez &{%2$s} de %1$s.
person.age = l’age

where @&{%s}@ is itself a message look-up, with the argument value as the message key.

p(note). **考察を続けます**
 
次: %(next)"キャッシュ":cache% 