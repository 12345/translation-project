<!--- Copyright (C) 2009-2015 Typesafe Inc. <http://www.typesafe.com> -->
<!--
# Debugging your build
-->
# ビルドをデバッグする

<!--
If you are having difficulties getting sbt to do what you want it to do, you may need to use some of the built in utilities that sbt provides to help you debug your build.
-->
sbt を思い通りに動かすのに手こずっているのであれば、ビルドのデバッグを支援するために sbt が提供している組み込みユーティリティをいくつか使う必要があるのかもしれません。

<!--
## Debugging dependencies
-->
## 依存性のデバッグ

<!--
By default, sbt generates reports of all your dependencies, including dependency trees to show which dependencies transitively brought in other dependencies, and conflict resolution tables showing how sbt decided which version of a dependency it selected when multiple were requested.
-->
sbt はデフォルトで、どの依存性が他の依存性に取り込まれているかを示す依存性ツリー、そして複数の依存性が要求されたときに sbt がどのようにしてバージョンを選択しているかを表示するコンフリクト解決テーブルを含む、すべての依存性のレポートを生成します。

<!--
The reports are generated into xml files, with an accompanying XSL stylesheet that allow browsers that support XSL to convert the XML reports into HTML.  Browsers with this support include Firefox and Safari, and notably don't include Chrome.
-->
このレポートは、XSL をサポートしているブラウザでは XML から HTML に変換できるようにする XSL スタイルシートを伴った XML ファイルとして生成されます。これをサポートしているブラウザには Firefox と Safari が含まれますが、注目すべきことに Chrome が含まれていません。

<!--
The reports can be found in the `target/resolution-cache/reports` directory of your project, one is generated for each scope in your project, and are named `organization-projectId_scalaVersion-scope.xml`, for example, `com.example-my-first-app_2.11-compile.xml`.  When opened in Firefox, this report looks something like this:
-->
このレポートはプロジェクトの `target/resolution-cache/reports` ディレクトリ内にプロジェクトのスコープごとに生成されており、例えば `com.example-my-first-app_2.11-compile.xml` のように `organization-projectId_scalaVersion-scope.xml` という名前が付けられています。このレポートは Firefox で開くと以下のように見えます:

[[images/ivy-report.png]]

<!--
## Debugging settings
-->
## 設定のデバッグ

<!--
There are a few useful commands that sbt provides that can be used to understand your build and work out where things may be going wrong.
-->
sbt は、ビルドを理解し、なにかおかしくなったところを解決するために使うことのできる便利なコマンドをいくつか提供しています。

<!--
### The show command
-->
### show コマンド

<!--
The show command shows the return value from any sbt task.  So for example, if you're not sure if a certain source file is being compiled or not, you can run `show sources` to see if sbt is including it in the sources:
-->
show コマンドはあらゆる sbt タスクの戻り値を表示します。例えば、あるソースファイルがコンパイルされるかどうかよく分からない場合、`show sources` を実行して sbt がそれをソースに含めているかどうか見ることができます:

```
[my-first-app] $ show sources
[info] ArrayBuffer(my-first-app/app/controllers/Application.scala, 
  my-first-app/target/scala-2.11/twirl/main/views/html/index.template.scala,
  my-first-app/target/scala-2.11/twirl/main/views/html/main.template.scala,
  my-first-app/target/scala-2.11/src_managed/main/routes_reverseRouting.scala,
  my-first-app/target/scala-2.11/src_managed/main/routes_routing.scala,
  my-first-app/target/scala-2.11/src_managed/main/controllers/routes.java)
```

<!--
The output above has been formatted to ensure it fits cleanly on the screen, you may need to copy it to an editor to make sense of it if the task you run returns a long list of items.
-->
上記の出力はスクリーンにぴったり収まるように整形されていますが、実行したタスクが長いリストを返す場合は、その内容を理解するためにエディタにコピーする必要があるかもしれません。

<!--
You can also specify a task a particular scope, eg `test:sources` or `compile:sources`, or for a particular project, `my-project/compile:sources`, and in some cases, where tasks are scoped by another task, you can specify that scope too, for example, to see everything that will be packaged into your projects jar file, you want to show the `mappings` task, scoped to the `packageBin` task:
-->
例えば `test:sources` や `compile:sources` のように、タスクに特定のスコープを指定したり、`my-project/compile:sources` のように特定のプロジェクトを指定することもできます。また、あるタスクが他のタスクのスコープとなっている別の場合は、そのスコープを指定することもできます。例えばプロジェクトの jar ファイルにパッケージされるものをすべて表示するには、`packageBin` タスクをスコープとする `mappings` タスクを表示します:

```
[my-first-app] $ show compile:packageBin::mappings
[info] List(
  (my-first-app/target/scala-2.11/classes/application.conf,application.conf),
  (my-first-app/target/scala-2.11/classes/controllers/Application.class,controllers/Application.class),
  ...
```

<!--
### The inspect command
-->
### inspect コマンド

<!--
The inspect command gives you detailed information about a task, including what it depends on, what depends on it, where it was defined, etc.  It can be used like the `show` command:
-->
inspect コマンドは、タスクが何に依存しているか、何から依存されているか、どこに定義されているか、などの詳細情報を提供します。これは `show` コマンドと同じように使うことができます:

```
[my-first-app] $ inspect managedSources
[info] Task: scala.collection.Seq[java.io.File]
[info] Description:
[info] 	Sources generated by the build.
[info] Provided by:
[info] 	{file:my-first-app/}root/compile:managedSources
[info] Defined at:
[info] 	(sbt.Defaults) Defaults.scala:185
[info] Dependencies:
[info] 	compile:sourceGenerators
[info] Reverse dependencies:
[info] 	compile:sources
...
```

<!--
Here we've inspected the `managedSources` command, it tells us that this is a task that produces a sequence of files, it has a description of `Sources generated by the build.`  You can see that it depends on the `sourceGenerators` task, and the `sources` task depends on it.  You can also see where it was defined, in this case, it's from sbt's default task definitions, line 185.
-->
ここでは `managedSources` コマンドを調査し、このタスクはファイルのシーケンスを提供すること、`Sources generated by the build` という説明文を持つことが分かります。`sourceGenerators` タスクに依存していること、`sources` タスクから依存されていることも確認できます。どこに定義されているかを確認することもできて、この場合は sbt のデフォルトタスク定義の 185 行目です。

<!--
### The inspect tree command
-->
### inspect tree コマンド

<!--
The inspect tree command shows a whole tree of task dependencies for a particular task.  If we inspect the tree for the `unmanagedSources` task, we can see it here:
-->
inspect tree コマンドは、あるタスクのタスクツリー全体を表示します。`unmanagedSources` タスクのタスクツリーを調査した場合、以下のように表示されます:

```
[my-first-app] $ inspect tree unmanagedSources
[info] compile:unmanagedSources = Task[scala.collection.Seq[java.io.File]]
[info]   +-*/*:sourcesInBase = true
[info]   +-*/*:unmanagedSources::includeFilter = sbt.SimpleFilter@3dc46f24
[info]   +-compile:unmanagedSourceDirectories = List(my-first-app/app, my-first-a..
[info]   | +-compile:javaSource = app
[info]   | | +-*:baseDirectory = my-first-app
[info]   | |   +-*:thisProject = Project(id root, base: my-first-app, configurations: List(compile,..
[info]   | |   
[info]   | +-compile:scalaSource = app
[info]   |   +-*:baseDirectory = my-first-app
[info]   |     +-*:thisProject = Project(id root, base: my-first-app, configurations: List(compile,..
[info]   |     
[info]   +-*:baseDirectory = my-first-app
[info]   +-*/*:excludeFilter = sbt.HiddenFileFilter$@49e479da
```

<!--
This shows the whole tree of tasks that sbt uses to discover the sources in your project, including the filters to decide which files to be included or excluded.  The `inspect tree` command is particularly useful when you're not sure how some part of your build is structured, and you want to find out how it all fits together so you can then dive in deeper.
-->
ここでは、どのファイルを含める、あるいは除外するかを判断するフィルタを含め、プロジェクト内にあるソースを発見するために sbt が使うタスクツリー全体が表示されています。`inspect tree` コマンドは、ビルドのある部分がどのように構築されていてのかよく分からず、それらがどのように組み合わさるのかを解明したい場合に特に便利で、これによりさらに詳しく調べていくことができます。

<!--
## Debugging incremental compilation
-->
## インクリメンタルコンパイルのデバッグ

<!--
A common problem that people have in Play is they find Play recompiles and reloads when they don't expect it to.  This is often caused by source generators or IDEs that inadvertently update elements of Play's classpath, forcing a reload.  To debug problems like this, we can look at the debug log from the compile task.  When sbt runs a task it captures all the log output, whether it displays it or not, so that you can inspect it later if you want.  It can be inspected using the `last` command.
-->
人々が Play に持っている共通の問題は、期待していないときに Play が再コンパイルし、再ロードすることです。多くの場合、これはソースジェネレータまたは IDE がなんらかの事情で Play クラスパスの要素を更新し、再ロードを強制することで引き起こされます。このような問題を解決するために、compile タスクのデバッグログを見ることができます。sbt はタスクを実行すると、それを表示するしないに関わらずログ出力をすべてキャプチャするので、必要な場合は後から調査することができます。これは `last` コマンドを使って調査することができます。

<!--
So, let's say you `compile`, and a file needs to be recompiled:
-->
さて、ここで `compile` を実行して、あるファイルを再コンパイルする必要があったとしましょう:

```
[my-first-app] $ compile
[info] Compiling 1 Scala source to my-first-app/target/scala-2.11/classes...
[success] Total time: 1 s, completed 07/04/2015 1:28:43 PM
```

<!--
You can get a full debug log of what happened during the compile command by running `last compile`.  This will dump a lot of output, but only the first part is what we are interested in, shown here:
-->
`last compile` を実行すると、compile コマンドの実行中に起こったことの完全なデバッグログを取得できます。大量のダンプが出力されますが、興味があるのは以下に示す最初の部分だけです:

```
[my-first-app] $ last compile
[debug]
[debug] Initial source changes:
[debug] 	removed:Set()
[debug] 	added: Set()
[debug] 	modified: Set(my-first-app/app/controllers/Application.scala)
[debug] Removed products: Set()
[debug] External API changes: API Changes: Set()
[debug] Modified binary dependencies: Set()
[debug] Initial directly invalidated sources: Set(my-first-app/app/controllers/Application.scala)
[debug]
[debug] Sources indirectly invalidated by:
[debug] 	product: Set()
[debug] 	binary dep: Set()
[debug] 	external source: Set()
```

<!--
What this tells us is that a recompile was triggered because `my-first-app/app/controllers/Application.scala` was modified.
-->
これは、`my-first-app/app/controllers/Application.scala` が変更されたために再コンパイルが引き起こされたことを伝えています。